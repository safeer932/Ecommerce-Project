# Avant de commencer le fichier CI/CD, tu dois savoir des choses.

#Premièrement, par exemple, si je dois déployer une application sur un serveur distant,
#je n’ai pas besoin de mettre le SSH, son mot de passe du server ou des choses comme ça pour montrer à la pipeline que cest sur ce server 
#que tu dois te connecter pour récupérer les dossiers de l'application il va savoir automqiuemtn
#
#Non, je n’ai pas besoin de faire cela, car si je crée le fichier CI/CD en restant connecté sur le serveur où il y aura les dossiers de l’application,
#et qu’après je crée le fichier CI/CD, lorsque je vais pousser sur GitLab, GitLab va le savoir automatiquement.

#De plus, pour le runner, regarde la vidéo de Shubham Londhe pour comprendre si tu te perds.
#Les runners sont importants pour faire marcher l’application.

#De plus, imaginons que les conteneurs sont déjà exécutés avec Docker Compose dans le serveur et que tu te demandes
#"Oh, faut-il que je supprime les conteneurs qui sont en cours pour faire marcher les nouveaux ?"

#Ne t’inquiète pas, il suffit de tout configurer en bas comme c’est configuré actuellement et ça va marcher automatiquement.
#Tu n’auras pas besoin de recréer les images ou de supprimer les images sur Docker Hub à chaque fois qu’il y a des mises à jour à faire sur l’application.
#Tout se fait automatiquement.

#Mais si jamais ça ne marche pas, essaye de supprimer les images sur Docker Hub,
#ainsi que sur le serveur avec la commande suivante 

#docker images

#Ensuite, ferme et supprime les conteneurs en cours avec cette commande spécifique 

#docker-compose down && docker rm -f $(docker ps -aq)

#enfin, mets le nom que tu veux pour la nouvelle image dans docker-compose.yml,
#change aussi le nom du conteneur, c’est-à-dire remplace l’ancien nom que tu avais donné
#et mets ce même nouveau nom dans le fichier Nginx.

#Voilà !


#de plus il faut tous le temps pousser par le serverus ou ya les fichiers/dosseir et le fichier ci parceque si tu pousse de un server ou ton cv perso 
#le pipeline il va te donner bcp derrerus comme les permissions etc etc donc vaut mieux tout modifer en restant connecter sur le server et pousser sur gitlab



#de plus tu vois si par exemple dans une entreprise ou meme des teste que tu veux faire en effet quand tu va deployer ton aplpication avec les fichiers k8s en heberegant
#le cluster sur une platefole cloud aws gcp gke etc ... ensuite bah qd tu le connecte avec ton centos et lorsque tu va deployer ton appliation sur ce cluster 
#avec les fichiers k8s et bah lorsque tu va faire la pipeline ci cd bah t'efface les cmmande docker comose tout en bas et tu met simplement les commande 
#kubectl apply -f deployer service ingress.yml cest tout

#ne pas oublier de changer la version de limage a chaque fois que tu pousse dans les fichiers deploient que sois pour le backend ou le frontend et ensuite mettre le meme nom ici dans le fichier ci-gitlab.yml a chaque fois que tu modifer bah tu change tres important


stages:
  - build
  - test 
  - push_to_dockerhub
  - deploy

build_job:
  stage: build
  script:
    - docker build -t frontend:latest /home/sahmad/mazon-comerce-microservices-application/front-end
  tags:
    - ecommerce_dev

test_job:
  stage: test
  script:
    - echo "testing"
  tags:
    - ecommerce_dev

push_job:
  stage: push_to_dockerhub
  script:
    - docker login -u $DOCKERHUB_USER -p $DOCKERHUB_PASS
    - docker image tag frontend:latest "$DOCKERHUB_USER/frontend:latest"
    - docker push "$DOCKERHUB_USER/frontend:latest"
  tags:
    - ecommerce_dev

deploy_job:
  stage: deploy
  script:
    - kubectl apply -f deployment/secret.yml
    - kubectl apply -f deployment/configmap-frontend.yml
    - kubectl apply -f deployment/ingress.yml
    - kubectl apply -f deployment/deployment-app.yml
    - kubectl apply -f deployment/service-app.yml
  tags:
    - ecommerce_dev

